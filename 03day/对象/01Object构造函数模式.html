<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
    // 方式一: Object构造函数模式
    //     * 套路: 先创建空Object对象, 再动态添加属性/方法
    //     * 适用场景: 起始时不确定对象内部数据
    //     * 问题: 语句太多

    // var obj = new Object();
    // obj.name = "张三";
    // obj.getName = function () {
    //     return this.name;
    // }


    // 方式二: 对象字面量模式
    //     * 套路: 使用{}创建对象, 同时指定属性/方法
    //     * 适用场景: 起始时对象内部数据是确定的
    //     * 问题: 如果创建多个对象, 有重复代码

    // var obj1 = {name: "zhangsan", age: 23};
    // var obj2 = {name: "lisi", age: 24};

    // 方式三: 工厂模式
    //     * 套路: 通过工厂函数动态创建对象并返回
    //     * 适用场景: 需要创建多个对象
    //     * 问题: 对象没有一个具体的类型, 都是Object类型

    // function Person(name, age) {
    //     return {
    //         name: name,
    //         age: age
    //     }
    // }
    //
    //
    // var person1 = Person('kobe', 43);
    // var person2 = Person('wade', 38);
    // person2.sex = '男';
    // console.log(person2);
    //
    // console.log(typeof person2);//object
    // console.log(person1 instanceof Person);//false

    // 方式四: 自定义构造函数模式
    //     * 套路: 自定义构造函数, 通过new创建对象
    //     * 适用场景: 需要创建多个类型确定的对象
    //     * 问题: 每个对象都有相同的数据, 浪费内存
    //！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    //！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    // 方式五: 构造函数+原型的组合模式
    //     * 套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上
    //     * 适用场景: 需要创建多个类型确定的对象

    function Person(name, age) {
        this.name = name;
        this.age = age;
    }
    Person.prototype.showName = function () {
        console.log(this.name);
    }
    var person1 = new Person('kobe', 43);
    var person2 = new Person('wade', 38);
    console.log(person1 instanceof Person); // true
    person1.showName();
    person2.showName();




</script>
</body>
</html>